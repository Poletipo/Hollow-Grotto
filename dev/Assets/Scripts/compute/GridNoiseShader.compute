// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PointsValue
#include "/includes/noise.compute"

struct Point {
    float3 pos;
    float val;
};

RWStructuredBuffer<Point> points;

int numPointsPerAxis;
float voxelSize;
float noiseScale;
float octaves;
StructuredBuffer<float3> randSeedOffsets;
float persistence;
float3 noiseOffset;
float3 chunkPosition;

int indexFromCoord(int x, int y, int z) {
    return z * numPointsPerAxis * numPointsPerAxis + y * numPointsPerAxis + x;
}

[numthreads(8,8,8)]
void PointsValue (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis) {
        return;
    }
    float3 position;
    float value;

    position = id * voxelSize + chunkPosition;

    float3 posValue = (position + noiseOffset) * noiseScale;

    //https://adrianb.io/2014/08/09/perlinnoise.html
    float total = 0;
    float frequency = 1;
    float amplitude = 1;
    float maxValue = 0;  // Used for normalizing result to 0.0 - 1.0
    for (int i = 0; i < octaves; i++) {
        total += snoise(posValue * frequency + randSeedOffsets[i]) * amplitude;

        maxValue += amplitude;

        amplitude *= persistence;
        frequency *= 2;
    }

    value = total / maxValue;
    
    int index = indexFromCoord(id.x, id.y, id.z);

    points[index].pos = position;
    points[index].val = value;
}
